<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geovisor Predios y Agua Potable</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
        }
        
        .container {
            display: flex;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }
        
        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
        
        .map-container {
            flex: 1;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        #map {
            height: 100%;
            width: 100%;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 22px;
            margin-bottom: 5px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-card.predios {
            background: linear-gradient(45deg, #e67e22, #d35400);
        }
        
        .stat-card.agua {
            background: linear-gradient(45deg, #1abc9c, #16a085);
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .control-group input, .control-group select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .btn {
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .btn.predios {
            background: linear-gradient(45deg, #e67e22, #d35400);
        }
        
        .btn.agua {
            background: linear-gradient(45deg, #1abc9c, #16a085);
        }
        
        .btn.secondary {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            display: none;
        }
        
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status {
            background: #ecf0f1;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .status.success {
            color: #27ae60;
        }
        
        .status.error {
            color: #e74c3c;
        }
        
        .layer-controls {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .layer-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        
        .zoom-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .popup-custom {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .popup-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .popup-field {
            margin-bottom: 4px;
        }
        
        .popup-field strong {
            color: #3498db;
        }

        /* Nuevos estilos para el modo adaptativo */
        .mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mode-btn {
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            background: white;
            color: #2c3e50;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .mode-btn.active {
            border-color: #3498db;
            background: #3498db;
            color: white;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e5e9;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #e67e22, #d35400);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1>üåç Geovisor Predios y Agua Potable</h1>
                <p>Visualizaci√≥n de informaci√≥n catastral</p>
            </div>
            
            <div id="status" class="status">üìç Inicializando mapa...</div>
            
            <!-- Selector de modo -->
            <div class="mode-selector">
                <div class="mode-btn active" onclick="setViewMode('adaptive')" id="modeAdaptive">
                    üì± Adaptivo
                </div>
                <div class="mode-btn" onclick="setViewMode('all')" id="modeAll">
                    üåç Todos
                </div>
            </div>
            
            <!-- Barra de progreso -->
            <div class="progress-bar" id="progressContainer" style="display:none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="layer-controls">
                <h3>Capas</h3>
                <div class="layer-toggle">
                    <label for="togglePredios">üèòÔ∏è Predios</label>
                    <label class="switch">
                        <input type="checkbox" id="togglePredios" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <label for="toggleAgua">üíß Red Agua Potable</label>
                    <label class="switch">
                        <input type="checkbox" id="toggleAgua" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="stats">
                <div class="stat-card predios">
                    <h3 id="totalPredios">0</h3>
                    <p>Total Predios</p>
                </div>
                <div class="stat-card agua">
                    <h3 id="totalTubosAgua">0</h3>
                    <p>Tubos Agua</p>
                </div>
                <div class="stat-card predios">
                    <h3 id="prediosVisibles">0</h3>
                    <p>Predios Visibles</p>
                </div>
                <div class="stat-card agua">
                    <h3 id="aguaVisibles">0</h3>
                    <p>Tubos Visibles</p>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="searchPredio">Buscar ID Predio:</label>
                    <input type="text" id="searchPredio" placeholder="Ej: ABC123">
                </div>
                
                <div class="control-group">
                    <label for="filterTipoPredio">Tipo de Predio:</label>
                    <select id="filterTipoPredio">
                        <option value="">Todos los tipos</option>
                        <option value="URBANO">Urbano</option>
                        <option value="RURAL">Rural</option>
                    </select>
                </div>
                
                <button class="btn predios" onclick="aplicarFiltrosPredios()">üîç Buscar Predios</button>
                
                <div class="control-group">
                    <label for="searchAgua">Buscar por AGUA:</label>
                    <input type="text" id="searchAgua" placeholder="Ej: TUBO_PVC">
                </div>
                
                <div class="control-group">
                    <label for="filterBarrio">Filtrar por Barrio:</label>
                    <select id="filterBarrio">
                        <option value="">Todos los barrios</option>
                    </select>
                </div>
                
                <button class="btn agua" onclick="aplicarFiltrosAgua()">üîç Buscar Agua Potable</button>
                
                <button class="btn secondary" onclick="limpiarFiltros()">üóëÔ∏è Limpiar Filtros</button>
                <button class="btn secondary" onclick="centrarEnElPangui()">üìç Centrar Mapa</button>
                <button class="btn secondary" onclick="cargarTodosPredios()">üìç Cargar Todos Predios</button>
            </div>
            
            <div id="loadingPredios" class="loading">
                <div class="spinner"></div>
                <p id="loadingTextPredios">Cargando predios...</p>
            </div>
            
            <div id="loadingAgua" class="loading">
                <div class="spinner"></div>
                <p>Cargando agua potable...</p>
            </div>
        </div>
        
        <div class="map-container">
            <div id="mapLoading" class="loading" style="display: none;">
                <div class="spinner"></div>
                <p id="loadingText">Cargando datos...</p>
            </div>
            <div class="zoom-info">
                Zoom: <span id="currentZoom">12</span> | 
                Predios: <span id="currentPredios">0</span> | 
                Agua: <span id="currentAgua">0</span> |
                Modo: <span id="currentMode">Adaptivo</span>
            </div>
            <div id="map"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Configuraci√≥n de Supabase
        const SUPABASE_URL = 'https://dpxlpyyelqbwudkhdtbw.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRweGxweXllbHFid3Vka2hkdGJ3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAxMjMwNjksImV4cCI6MjA2NTY5OTA2OX0.j8evYP_owzPeJmZ5GgdHnjpg1dYE4DShcI9fYYA8xG8';
        const EL_PANGUI_COORDS = [-3.6167, -78.55];
        
        // Variables globales
        let map;
        const prediosLayer = L.layerGroup();
        const aguaLayer = L.layerGroup();
        let currentPrediosData = [], currentAguaData = [];
        let loading = false, zoom = 12, timer;
        let viewMode = 'adaptive';
        let allPrediosCache = null;
        let allAguaCache = null;
        
        // Configuraci√≥n para modo adaptativo
        const ADAPTIVE_LIMITS = {
            8:  { limit: 500,  method: 'centroids' },
            10: { limit: 2000, method: 'centroids' },
            12: { limit: 5000, method: 'simplified' },
            14: { limit: null, method: 'normal' },
            16: { limit: null, method: 'normal' }
        };

        // Funci√≥n para inicializar el mapa
        function initMap() {
            map = L.map('map').setView(EL_PANGUI_COORDS, zoom);
            
            // Capa base
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap'
            }).addTo(map);
            
            // A√±adir capas de datos al mapa
            prediosLayer.addTo(map);
            aguaLayer.addTo(map);
            
            // Configurar toggles de capas
            document.getElementById('togglePredios').addEventListener('change', function(e) {
                e.target.checked ? prediosLayer.addTo(map) : map.removeLayer(prediosLayer);
            });
            
            document.getElementById('toggleAgua').addEventListener('change', function(e) {
                e.target.checked ? aguaLayer.addTo(map) : map.removeLayer(aguaLayer);
            });
            
            // Eventos del mapa
            map.on('zoomend', function() {
                const newZoom = map.getZoom();
                document.getElementById('currentZoom').textContent = newZoom;
                if (newZoom !== zoom) {
                    zoom = newZoom;
                    if (viewMode === 'adaptive') {
                        clearTimeout(timer);
                        timer = setTimeout(loadPrediosAdaptive, 500);
                    }
                }
            });
            
            map.on('moveend', function() {
                if (viewMode === 'adaptive') {
                    clearTimeout(timer);
                    timer = setTimeout(loadPrediosAdaptive, 500);
                }
            });
            
            updateStatus('Mapa listo', 'success');
            
            // Cargar datos iniciales
            loadPrediosAdaptive();
            cargarAgua();
        }
        
        // Funci√≥n para cargar predios en modo adaptativo
        async function loadPrediosAdaptive() {
            if (loading || viewMode !== 'adaptive') return;
            loading = true;
            showLoader(true, 'Cargando datos adaptativos...');
            
            try {
                const bounds = map.getBounds();
                const zoomLevel = Math.floor(zoom);
                const config = ADAPTIVE_LIMITS[
                    Object.keys(ADAPTIVE_LIMITS).reverse().find(l => zoomLevel >= l) || 8
                ];
                
                let url = `${SUPABASE_URL}/rest/v1/predios_texto?` +
                    `select=objectid,id_pred,tipo_pred,uso_pred,area_graf,desprov,descan,avaluo_tot,geom` +
                    `&order=area_graf.desc`;
                
                // Aplicar l√≠mite si existe en la configuraci√≥n
                if (config.limit) {
                    url += `&limit=${config.limit}`;
                }
                
                // Para zooms altos, filtrar por bounding box
                if (zoomLevel >= 12) {
                    url += `&geom=cs.{"type":"Polygon","coordinates":[[[${bounds.getWest()},${bounds.getSouth()}],` +
                        `[${bounds.getEast()},${bounds.getSouth()}],[${bounds.getEast()},${bounds.getNorth()}],` +
                        `[${bounds.getWest()},${bounds.getNorth()}],[${bounds.getWest()},${bounds.getSouth()}]]]}`;
                }
                
                const response = await fetch(url, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });
                
                if (!response.ok) throw new Error(`Error ${response.status}`);
                
                let data = await response.json();
                
                // Simplificar geometr√≠as para zooms bajos
                if (config.method === 'centroids' && data.length > 0) {
                    data = data.map(item => {
                        if (item.geom) {
                            try {
                                const geo = typeof item.geom === 'string' ? JSON.parse(item.geom) : item.geom;
                                let centroid = [0, 0];
                                if (geo.type === 'Polygon' && geo.coordinates && geo.coordinates[0]) {
                                    const coords = geo.coordinates[0];
                                    const len = coords.length;
                                    centroid = coords.reduce((acc, coord) => [acc[0] + coord[0], acc[1] + coord[1]], [0, 0]);
                                    centroid = [centroid[0] / len, centroid[1] / len];
                                }
                                item.geom = {
                                    type: 'Point',
                                    coordinates: centroid
                                };
                            } catch (e) {
                                console.warn('Error procesando geometr√≠a:', e);
                            }
                        }
                        return item;
                    });
                }
                
                currentPrediosData = data;
                renderizarPredios(data);
                updateStatus(`‚úÖ Cargados: ${data.length} predios (modo adaptativo)`, 'success');
                
            } catch (error) {
                console.error('Error cargando predios adaptativos:', error);
                updateStatus(`Error predios: ${error.message}`, 'error');
            } finally {
                loading = false;
                showLoader(false);
            }
        }
        
        // Funci√≥n para cargar TODOS los predios
        async function cargarTodosPredios() {
            if (loading) return;
            loading = true;
            showProgress(true);
            showLoader(true, 'Iniciando carga masiva de predios...');
            
            try {
                // Intentar funci√≥n RPC optimizada primero
                try {
                    setLoadingText('üöÄ Probando funci√≥n RPC get_predios_geo...');
                    updateProgress(10);
                    
                    const data = await callRPC('get_predios_geo', {});
                    
                    updateProgress(80);
                    setLoadingText('üìä Procesando geometr√≠as RPC...');
                    
                    currentPrediosData = data.map(item => ({
                        objectid: item.objectid,
                        id_pred: item.id_pred || '',
                        tipo_pred: item.tipo_pred || '',
                        uso_pred: item.uso_pred || '',
                        area_graf: item.area_graf,
                        desprov: item.desprov || '',
                        descan: item.descan || '',
                        avaluo_tot: item.avaluo_tot,
                        geom: item.geom
                    }));
                    
                    allPrediosCache = currentPrediosData;
                    updateProgress(100);
                    setLoadingText('‚úÖ Renderizando desde RPC...');
                    
                    setTimeout(() => {
                        renderizarPredios(currentPrediosData);
                        updateStatus(`üéâ Carga RPC exitosa: ${currentPrediosData.length.toLocaleString()} predios`, 'success');
                    }, 200);
                    
                } catch (rpcError) {
                    console.warn('RPC get_predios_geo fall√≥:', rpcError);
                    setLoadingText('üì¶ RPC fall√≥ - usando carga por lotes...');
                    updateProgress(0);
                    
                    // Fallback: Carga por lotes tradicional
                    const batchSize = 1000;
                    let offset = 0;
                    let allData = [];
                    let batchCount = 0;
                    let hasMore = true;
                    
                    while (hasMore && offset < 15000) {
                        batchCount++;
                        setLoadingText(`üì• Cargando lote ${batchCount} (${offset}-${offset + batchSize})...`);
                        updateProgress((offset / 15000) * 100);
                        
                        try {
                            const batch = await loadBatchPredios(offset, batchSize);
                            
                            if (batch.length === 0) {
                                hasMore = false;
                            } else {
                                allData.push(...batch);
                                offset += batchSize;
                                await new Promise(resolve => setTimeout(resolve, 100));
                                
                                if (batchCount % 2 === 0) {
                                    document.getElementById('prediosVisibles').textContent = allData.length.toLocaleString();
                                }
                            }
                            
                            if (batch.length < batchSize) {
                                hasMore = false;
                            }
                            
                        } catch (batchError) {
                            console.error(`Error en lote ${batchCount}:`, batchError);
                            offset += batchSize;
                            if (batchCount > 15) {
                                hasMore = false;
                            }
                        }
                    }
                    
                    allPrediosCache = allData;
                    currentPrediosData = allData;
                    updateProgress(100);
                    setLoadingText('‚úÖ Renderizando desde lotes...');
                    
                    setTimeout(() => {
                        renderizarPredios(currentPrediosData);
                        updateStatus(`‚úÖ Carga por lotes exitosa: ${currentPrediosData.length.toLocaleString()} predios`, 'success');
                    }, 200);
                }
                
            } catch (e) {
                console.error('Error en carga masiva:', e);
                updateStatus('‚ùå Error general en carga masiva', 'error');
            } finally {
                loading = false;
                setTimeout(() => {
                    showLoader(false);
                    showProgress(false);
                }, 500);
            }
        }
        
        // Funci√≥n para cargar un lote de predios
        async function loadBatchPredios(offset, limit) {
            const url = `${SUPABASE_URL}/rest/v1/predios_texto?select=objectid,id_pred,tipo_pred,uso_pred,area_graf,desprov,descan,avaluo_tot,geom&offset=${offset}&limit=${limit}&order=objectid.asc`;
            
            const response = await fetch(url, {
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
            return await response.json();
        }
        
        // Funci√≥n para llamar a RPC de Supabase
        async function callRPC(functionName, params) {
            const res = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${functionName}`, {
                method: 'POST',
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(params)
            });
            
            if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`RPC Error ${res.status}: ${errorText}`);
            }
            return await res.json();
        }
        
        // Funci√≥n para renderizar predios en el mapa
        function renderizarPredios(data) {
            prediosLayer.clearLayers();
            let contador = 0;
            
            data.forEach(item => {
                if (!item.geom) return;
                
                try {
                    const geom = typeof item.geom === 'string' ? JSON.parse(item.geom) : item.geom;
                    
                    let layer;
                    if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                        // Render como pol√≠gono con borde visible pero sin relleno
                        layer = L.geoJSON(geom, {
                            style: {
                                color: getColorPredio(item.tipo_pred),
                                weight: zoom > 14 ? 2 : 1,
                                fillOpacity: 0, // Sin relleno
                                opacity: 1,    // Borde completamente visible
                                fillColor: 'transparent'
                            }
                        }).bindPopup(crearPopupPredio(item));
                    } else if (geom.type === 'Point') {
                        // Render como c√≠rculo para centroides
                        layer = L.circleMarker([geom.coordinates[1], geom.coordinates[0]], {
                            radius: Math.min(zoom, 8),
                            color: getColorPredio(item.tipo_pred),
                            weight: 2,
                            fillOpacity: 0.7
                        }).bindPopup(crearPopupPredio(item));
                    }
                    
                    if (layer) {
                        prediosLayer.addLayer(layer);
                        contador++;
                    }
                } catch (e) {
                    console.error('Error renderizando predio:', e);
                }
            });
            
            document.getElementById('totalPredios').textContent = currentPrediosData.length.toLocaleString();
            document.getElementById('prediosVisibles').textContent = contador.toLocaleString();
            document.getElementById('currentPredios').textContent = contador.toLocaleString();
            
            if (contador > 0 && viewMode === 'all') {
                setTimeout(() => {
                    try {
                        map.fitBounds(prediosLayer.getBounds(), {padding: [50, 50]});
                    } catch (e) {
                        console.warn('Error ajustando vista:', e);
                    }
                }, 100);
            }
        }
        
        // Funci√≥n para cargar agua potable desde Supabase
        async function cargarAgua(filtros = {}) {
            const loadingElement = document.getElementById('loadingAgua');
            loadingElement.style.display = 'block';
            
            try {
                // Consulta con las columnas exactas de tu tabla
                let query = `${SUPABASE_URL}/rest/v1/red_agua_potable?select=id,OBJECTID,Layer,AGUA,AREA,PAR_BARRIO,Shape_Leng,geom`;
                
                const conditions = [];
                if (filtros.agua) conditions.push(`AGUA.ilike.%${filtros.agua}%`);
                if (filtros.barrio) conditions.push(`PAR_BARRIO.ilike.%${filtros.barrio}%`);
                
                if (conditions.length > 0) query += `&${conditions.join('&')}`;
                
                query += '&limit=500';
                
                const response = await fetch(query, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Error ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                currentAguaData = data;
                renderizarAgua(data);
                cargarBarriosDisponibles(data);
                
                updateStatus(`Agua potable cargada: ${data.length} registros`, 'success');
                return data;
            } catch (error) {
                console.error('Error cargando agua potable:', error);
                updateStatus(`Error: ${error.message}`, 'error');
                throw error;
            } finally {
                loadingElement.style.display = 'none';
            }
        }
        
        // Funci√≥n para renderizar agua potable en el mapa
        function renderizarAgua(data) {
            aguaLayer.clearLayers();
            let contador = 0;
            
            if (!data || data.length === 0) {
                console.warn('No hay datos de agua potable para renderizar');
                updateStatus('No hay datos de agua potable', 'error');
                return;
            }

            data.forEach(item => {
                try {
                    // Procesar la geometr√≠a
                    let geom;
                    if (item.geom) {
                        geom = typeof item.geom === 'string' ? JSON.parse(item.geom) : item.geom;
                    } else {
                        console.warn('Elemento sin geometr√≠a:', item);
                        return;
                    }

                    // Validar la geometr√≠a
                    if (!geom || !geom.type || !geom.coordinates) {
                        console.warn('Geometr√≠a inv√°lida:', geom);
                        return;
                    }

                    // Estilo llamativo para mejor visibilidad
                    const estilo = {
                        color: '#1E90FF', // Azul brillante
                        weight: 4,        // Grueso
                        opacity: 1,       // Totalmente opaco
                        lineCap: 'round',
                        lineJoin: 'round',
                        dashArray: item.AGUA === 'PRINCIPAL' ? null : '5, 3'
                    };

                    // Crear la capa
                    const layer = L.geoJSON(geom, {
                        style: estilo
                    }).bindPopup(crearPopupAgua(item));

                    aguaLayer.addLayer(layer);
                    contador++;

                } catch (e) {
                    console.error('Error renderizando elemento de agua:', e, item);
                }
            });

            // Actualizar UI
            document.getElementById('totalTubosAgua').textContent = data.length.toLocaleString();
            document.getElementById('aguaVisibles').textContent = contador.toLocaleString();
            document.getElementById('currentAgua').textContent = contador.toLocaleString();

            // Ajustar vista si hay elementos
            if (contador > 0) {
                setTimeout(() => {
                    try {
                        const bounds = aguaLayer.getBounds();
                        if (bounds.isValid()) {
                            map.fitBounds(bounds, { padding: [50, 50], maxZoom: 18 });
                        }
                    } catch (e) {
                        console.warn('Error ajustando vista:', e);
                    }
                }, 300);
            }
        }
        
        // Funciones auxiliares para estilos
        function getColorPredio(tipo) {
            const colors = {
                'URBANO': '#e74c3c',
                'RURAL': '#2ecc71',
                'INDUSTRIAL': '#3498db',
                'COMERCIAL': '#f39c12',
                'RESIDENCIAL': '#9b59b6'
            };
            return colors[tipo] || '#e67e22';
        }
        
        // Funciones para crear popups
        function crearPopupPredio(item) {
            return `
                <div class="popup-custom">
                    <div class="popup-title">üèòÔ∏è Predio: ${item.id_pred || 'N/A'}</div>
                    <div class="popup-field"><strong>ID:</strong> ${item.objectid || 'N/A'}</div>
                    <div class="popup-field"><strong>Tipo:</strong> ${item.tipo_pred || 'N/A'}</div>
                    <div class="popup-field"><strong>Uso:</strong> ${item.uso_pred || 'N/A'}</div>
                    <div class="popup-field"><strong>√Årea:</strong> ${item.area_graf ? item.area_graf + ' m¬≤' : 'N/A'}</div>
                    <div class="popup-field"><strong>Provincia:</strong> ${item.desprov || 'N/A'}</div>
                    <div class="popup-field"><strong>Cant√≥n:</strong> ${item.descan || 'N/A'}</div>
                    <div class="popup-field"><strong>Aval√∫o:</strong> ${item.avaluo_tot ? '$' + parseFloat(item.avaluo_tot).toLocaleString('es-ES', {minimumFractionDigits: 2}) : 'N/A'}</div>
                </div>
            `;
        }
        
        function crearPopupAgua(item) {
            return `
                <div class="popup-custom">
                    <div class="popup-title">üíß Agua Potable: ${item.OBJECTID || 'N/A'}</div>
                    <div class="popup-field"><strong>Tipo:</strong> ${item.AGUA || 'N/A'}</div>
                    <div class="popup-field"><strong>Layer:</strong> ${item.Layer || 'N/A'}</div>
                    <div class="popup-field"><strong>Barrio:</strong> ${item.PAR_BARRIO || 'N/A'}</div>
                    <div class="popup-field"><strong>√Årea:</strong> ${item.AREA ? item.AREA.toFixed(2) + ' m¬≤' : 'N/A'}</div>
                    <div class="popup-field"><strong>Longitud:</strong> ${item.Shape_Leng ? item.Shape_Leng.toFixed(2) + ' m' : 'N/A'}</div>
                </div>
            `;
        }
        
        // Funciones para cargar filtros
        function cargarBarriosDisponibles(data) {
            const select = document.getElementById('filterBarrio');
            const barrios = [...new Set(data.map(item => item.PAR_BARRIO).filter(Boolean))];
            
            select.innerHTML = '<option value="">Todos los barrios</option>';
            barrios.forEach(barrio => {
                const option = document.createElement('option');
                option.value = barrio;
                option.textContent = barrio;
                select.appendChild(option);
            });
        }
        
        // Funciones para aplicar filtros
        function aplicarFiltrosPredios() {
            const filtros = {
                id: document.getElementById('searchPredio').value.trim(),
                tipo: document.getElementById('filterTipoPredio').value
            };
            
            if (viewMode === 'all' && allPrediosCache) {
                // Filtrar en el cache
                const filtered = allPrediosCache.filter(item => {
                    const matchesId = !filtros.id || 
                        (item.id_pred && item.id_pred.toLowerCase().includes(filtros.id.toLowerCase()));
                    const matchesTipo = !filtros.tipo || 
                        (item.tipo_pred && item.tipo_pred === filtros.tipo);
                    return matchesId && matchesTipo;
                });
                renderizarPredios(filtered);
                updateStatus(`Filtrados ${filtered.length} predios`, 'success');
            } else {
                // Usar consulta directa
                cargarPredios(filtros);
            }
        }
        
        function aplicarFiltrosAgua() {
            const filtros = {
                agua: document.getElementById('searchAgua').value.trim(),
                barrio: document.getElementById('filterBarrio').value
            };
            cargarAgua(filtros);
        }
        
        function limpiarFiltros() {
            document.getElementById('searchPredio').value = '';
            document.getElementById('filterTipoPredio').value = '';
            document.getElementById('searchAgua').value = '';
            document.getElementById('filterBarrio').value = '';
            
            if (viewMode === 'adaptive') {
                loadPrediosAdaptive();
            } else if (allPrediosCache) {
                renderizarPredios(allPrediosCache);
            }
            
            cargarAgua();
        }
        
        function centrarEnElPangui() {
            map.setView(EL_PANGUI_COORDS, 12);
            updateStatus('Centrado en El Pangui', 'success');
        }
        
        function updateStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = type ? `status ${type}` : 'status';
        }
        
        // Funciones para manejar el modo de vista
        function setViewMode(mode) {
            viewMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'adaptive' ? 'modeAdaptive' : 'modeAll').classList.add('active');
            document.getElementById('currentMode').textContent = mode === 'adaptive' ? 'Adaptivo' : 'Todos';
            
            if (mode === 'adaptive') {
                loadPrediosAdaptive();
            } else {
                if (!allPrediosCache) {
                    cargarTodosPredios();
                } else {
                    renderizarPredios(allPrediosCache);
                }
            }
        }
        
        // Funciones para mostrar carga
        function showLoader(show, text = 'Cargando predios...') {
            const loader = document.getElementById('mapLoading');
            loader.style.display = show ? 'block' : 'none';
            if (text) setLoadingText(text);
        }
        
        function setLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }
        
        function showProgress(show) {
            const container = document.getElementById('progressContainer');
            container.style.display = show ? 'block' : 'none';
            if (!show) {
                updateProgress(0);
            }
        }
        
        function updateProgress(percent) {
            const fill = document.getElementById('progressFill');
            const clampedPercent = Math.min(Math.max(percent, 0), 100);
            fill.style.width = `${clampedPercent}%`;
            
            if (percent > 0) {
                const loadingText = document.getElementById('loadingText');
                loadingText.textContent = `Cargando... ${clampedPercent.toFixed(1)}%`;
            }
        }
        
        // Inicializaci√≥n
        window.onload = function() {
            initMap();
        };
    </script>
</body>
</html>
